"use strict";

var _path = _interopRequireDefault(require("path"));

var _register = _interopRequireDefault(require("@babel/register"));

var _babelMerge = _interopRequireDefault(require("babel-merge"));

var _schemaNormalizer = require("./schema-normalizer");

var _defaultBabelOptions = require("./default-babel-options");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @ts-expect-error no types or 3rd party types
// @ts-expect-error no types or 3rd party types
async function loadAndExecute() {
  const {
    schemaPath,
    babelOptions: babelOptionsFromArgs,
    babelrcPath,
    cwd
  } = await new Promise(resolve => {
    process.on('message', message => {
      resolve(JSON.parse(message));
    });
  });

  const babelConfigFromBabelrcPath = (() => {
    if (!babelrcPath) return {};

    const requiredBabelrc = require(babelrcPath);

    return requiredBabelrc.default || requiredBabelrc;
  })();

  (0, _register.default)({ ...(0, _babelMerge.default)(_defaultBabelOptions.defaultBabelOptions, (0, _babelMerge.default)(babelOptionsFromArgs || {}, babelConfigFromBabelrcPath)),
    cwd
  });

  const types = // this executes the schema using the previously configured babel to shim
  // out the parts
  require(_path.default.resolve(schemaPath)).default || require(_path.default.resolve(schemaPath));

  const result = (0, _schemaNormalizer.schemaNormalizer)(types);
  const executorResult = {
    status: 'success',
    result
  };
  process.send(JSON.stringify(executorResult));
}

loadAndExecute().catch(e => {
  const executorResult = {
    status: 'error',
    error: JSON.stringify({
      message: e === null || e === void 0 ? void 0 : e.message,
      stack: e === null || e === void 0 ? void 0 : e.stack
    }, null, 2)
  };
  process.send(JSON.stringify(executorResult));
  process.exit(1);
});